### Порядок установки и запуска
1. `npm install` или `yarn install`
2. `npm run exec`

### Инструментарий
* gulp и babel привлечены для доступа к [spread](http://babeljs.io/docs/plugins/transform-object-rest-spread/) оператору над объектами.
* redux - для менеджмента состояния.

### Как работает
* С помощью `redux` создается `store`, который хранит все состояние программы.
* store предоставляет методы `dispatch` и `subscribe` для генерации событий (actions) и реагирования на изменения состояния.
* `actionEmitter` генерит события из файла `listOfActions.json`, используя `dispatch`.
* `store` реагирует на события, переходя в новое состояние, которое формирует функция `reducer`.
* `reducer` осуществляет проверку валидности события и возвращает старое состояние, если событие невалидно.
* При смене состояния, срабатывает метод `subscribe`, который вызывает функцию `logger`.
* `logger`, анализируя текущее состояние и произошедшее событие, возвращает читаемую интерпретацию события, которая затем направляется в консоль.

### Примечания
1. Предполагается, что установленная версия node.js понимает es6.
2. При запуске `gulp execute` манера вывода сообщений отличается от предусмотренной.
3. Скорее всего, применение библиотеки Immutable.js позволило бы избежать "вырвиглазности" отдельных кусков кода.

### Исходный текст задачи
---

Ваша команда разрабатывает пошаговую текстовую игру для консолей нового поколения. Игроки совершают действия, посылая текстовые команды на сервер. Каждый ход состояние мира обновляется, учитывая совершенные действия, и клиенты оповещаются об изменениях. Текущее состояние мира сериализуется и хранится в базе.

Вам поручили реализовать программное представление игрового мира и его обновления. Как вы будете это делать - дело ваше, но помните, что на начальной стадии может быть много изменений и хорошо бы сразу подумать о расширяемости.

**Задача:**

1) Подписаться на получение сообщений о действиях, произошедших, за последний ход, используя модуль `updates` (метод `subscribe(callback)`). Можно написать свой эквивалент.

Каждое сообщение - это массив действий, произошедших в игровом мире. Порядок действий имеет значение. Формат сообщения:

```json
[
   { "type": "add player", "playerId": 55, "class": "human", "hp": 100, "weapon": "baseball bat", "x": 100, "y": 20 },
   { "type": "move", "playerId": 2, "x": 24, "y": 18 },
   { "type": "change weapon", "playerId": 3, "weapon": "shotgun" },
   { "type": "attack", "playerId": 4, "targetId": 3 }
]
```

2) При обработке действия `add player` нужно добавить нового игрока. Описание игрока содержит его id (`playerId`), класс (`class`), очки жизней (`hp`), текущее оружие (`weapon`) и координаты (`x` и `y`). Поля могут иметь следующие значения:

```
playerId - целое число больше нуля;
class - 'human', 'alien';
hp - целое число больше нуля;
weapon - 'baseball bat', 'knife', 'shotgun', 'laser gun';
x - целое число больше нуля;
y - целое число больше нуля;
```

3) При обработке события `move` нужно сместить игрока в указанные координаты.

4) При обработке события `change weapon` нужно дать игроку указанное оружие. Ограничения на возможное оружие см. выше.

5) При обработке события `attack` игрок атакует другого игрока тем оружием, которое сейчас использует. Урон для разного типа оружия:

```
knife - 5;
baseball bat - 10;
shotgun - 30;
laser gun - 35;
```

6) Если какой-то игрок погибает (`hp` <= 0), то все последующие действия этого игрока и действия по отношению к нему - игнорируются.

7) Игра заканчивается, когда в живых остается один игрок, об этом нужно вывести сообщение в консоли с указанием победившего игрока.

**Дополнительно:**

8) При совершении любого действия выводить в консоль лог об этом действии в human-readable формате, например: `Player 15 entered the world as alien`, `Player 23 moved to position 25 78` или `Player 4 was killed by player 3 with shotgun`.
